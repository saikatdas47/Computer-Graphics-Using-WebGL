<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Museum â€” Spotlight on Statue</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      color: white;
    }

    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 6px;
      font-size: 14px;
      line-height: 1.5;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <div id="info">
    <b>Controls:</b><br>
    R = toggle autorotate<br>
    Q = toggle floor colors (green/yellow)<br>
    W = toggle floor colors (black/white)<br>
    T = toggle painting animation
  </div>

  <script type="module">
    import * as THREE from './js/three.module.js';
    import { OrbitControls } from './js/OrbitControls.js';
    import { GLTFLoader } from './js/GLTFLoader.js';

    // --- Scene, camera, renderer ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // black background

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 6, 18);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.physicallyCorrectLights = true;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // --- Controls ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 2, 0);

    let autoRotate = false;

    // --- Floor (checkerboard shader) ---
    const floorUniforms = {
      color1: { value: new THREE.Color(0x111111) },
      color2: { value: new THREE.Color(0xaaaaaa) }
    };
    const floorShader = {
      uniforms: floorUniforms,
      vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv * 10.0;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }`,
      fragmentShader: `
          varying vec2 vUv;
          uniform vec3 color1;
          uniform vec3 color2;
          void main() {
            float cx = step(0.5, fract(vUv.x));
            float cy = step(0.5, fract(vUv.y));
            float c = mod(cx+cy,2.0);
            gl_FragColor = vec4(mix(color1, color2, c), 1.0);
          }`
    };
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(40, 40),
      new THREE.ShaderMaterial({ ...floorShader, side: THREE.DoubleSide })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Shadow catcher plane
    const shadowPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(40, 40),
      new THREE.ShadowMaterial({ opacity: 0.35 })
    );
    shadowPlane.rotation.x = -Math.PI / 2;
    shadowPlane.receiveShadow = true;
    scene.add(shadowPlane);

    // --- Walls ---
    const texLoader = new THREE.TextureLoader();
    const wallTexture = texLoader.load('./wall.jpg');
    const wallMat = new THREE.MeshStandardMaterial({ map: wallTexture });

    const wallThickness = 0.5;
    const wallWidth = 40;
    const wallHeight = 10;
    const wallY = wallHeight / 2 + wallThickness / 2;

    const leftWall = new THREE.Mesh(
      new THREE.BoxGeometry(wallThickness, wallHeight, wallWidth),
      wallMat
    );
    leftWall.position.set(-20 - wallThickness / 2, wallY, 0);
    scene.add(leftWall);

    const rightWall = new THREE.Mesh(
      new THREE.BoxGeometry(wallThickness, wallHeight, wallWidth),
      wallMat
    );
    rightWall.position.set(20 + wallThickness / 2, wallY, 0);
    scene.add(rightWall);

    const backWall = new THREE.Mesh(
      new THREE.BoxGeometry(wallWidth + 1, wallHeight, wallThickness),
      wallMat
    );
    backWall.position.set(0, wallY, -20 - wallThickness / 2);
    scene.add(backWall);

    // --- Custom Painting Frame ---
const paintingGroup = new THREE.Group();
scene.add(paintingGroup);

const paintingUniforms = {
  time: { value: 0.0 },
  style: { value: 0 } // 0 = RGB swirl, 1 = wave mode
};

const paintingShader = {
  uniforms: paintingUniforms,
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    uniform float time;
    uniform int style;
    varying vec2 vUv;
    void main() {
      vec3 color;
      if (style == 0) {
        // Style 0: RGB swirl
        color = vec3(
          0.5 + 0.5 * sin(time + vUv.x * 6.283),
          0.5 + 0.5 * sin(time + vUv.y * 6.283 + 2.0),
          0.5 + 0.5 * sin(time + (vUv.x+vUv.y) * 6.283 + 4.0)
        );
      } else {
        // Style 1: horizontal wave
        color = vec3(
          0.5 + 0.5 * sin(3.0 * vUv.x + time),
          0.5 + 0.5 * sin(3.0 * vUv.y + time * 1.2),
          0.5 + 0.5 * sin(time + vUv.x * 5.0)
        );
      }
      gl_FragColor = vec4(color, 1.0);
    }
  `
};

const paintingCanvas = new THREE.Mesh(
  new THREE.PlaneGeometry(8, 5),
  new THREE.ShaderMaterial({
    ...paintingShader,
    side: THREE.DoubleSide
  })
);
paintingCanvas.position.z = 0.1;
paintingGroup.add(paintingCanvas);

const frame = new THREE.Mesh(
  new THREE.BoxGeometry(8.4, 5.4, 0.3),
  new THREE.MeshStandardMaterial({ color: 0xFFD700 })
);
paintingGroup.add(frame);

paintingGroup.position.set(0, 5.5, -19.5);

let frameStyle = 0;
let frameActive = false;

    // --- Statue ---
    const gltfLoader = new GLTFLoader();
    let statue = null;
    let statueCenter = new THREE.Vector3();
    let statueHeight = 10;

    gltfLoader.load('./statue/scene.gltf', (gltf) => {
      statue = gltf.scene;
      statue.traverse((c) => {
        if (c.isMesh) {
          c.castShadow = true;
          c.receiveShadow = true;
          if (c.material && c.material.isMeshStandardMaterial) {
            c.material.metalness = 0.2;
            c.material.roughness = 0.6;
          }
        }
      });

      const box = new THREE.Box3().setFromObject(statue);
      const size = new THREE.Vector3();
      box.getSize(size);

      const desiredHeight = 5.0;
      const scaleFactor = size.y > 0 ? (desiredHeight / size.y) : 1;
      statue.scale.setScalar(scaleFactor);

      const scaledBox = new THREE.Box3().setFromObject(statue);
      scaledBox.getCenter(statueCenter);
      const scaledSize = new THREE.Vector3();
      scaledBox.getSize(scaledSize);
      statueHeight = scaledSize.y;

      statue.position.y = scaledSize.y / 2;
      statue.position.z = -2.5;

      scene.add(statue);
    });

    // --- Lights ---
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.4));
    scene.add(new THREE.AmbientLight(0x222222, 0.4));

    const spotLight = new THREE.SpotLight(0xffffff, 400, 40, Math.PI / 6, 0.25, 2);
    spotLight.castShadow = true;
    spotLight.shadow.mapSize.width = 4096;
    spotLight.shadow.mapSize.height = 4096;
    spotLight.shadow.camera.near = 0.5;
    spotLight.shadow.camera.far = 80;
    scene.add(spotLight);
    scene.add(spotLight.target);

    // --- Animation loop ---
    function animate() {
      requestAnimationFrame(animate);

      controls.autoRotate = autoRotate;
      controls.autoRotateSpeed = 2.0;
      controls.update();

      if (statue) {
        const time = performance.now() * 0.001;
        const radius = 6;

        spotLight.position.set(
          statueCenter.x + Math.sin(time) * radius,
          statueHeight + 5,
          statueCenter.z + Math.cos(time) * radius
        );

        spotLight.target.position.copy(statueCenter);
        spotLight.target.updateMatrixWorld();
      }

      // Painting shader always animated
      if (paintingCanvas.material.uniforms) {
        paintingCanvas.material.uniforms.time.value = performance.now() * 0.001;
      }

      // Painting frame animation
      if (frameActive) {
        const t = performance.now() * 0.001;
        if (frameStyle === 0) {
          paintingGroup.rotation.y = Math.sin(t) * 0.2;
          paintingGroup.scale.set(1, 1, 1);
        } else {
          const scale = 1 + Math.sin(t * 3) * 0.1;
          paintingGroup.scale.set(scale, scale, scale);
          paintingGroup.rotation.y = 0;
        }
      } else {
        paintingGroup.rotation.y = 0;
        paintingGroup.scale.set(1, 1, 1);
      }

      renderer.render(scene, camera);
    }
    animate();

    // --- Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- Keyboard shortcuts ---
    window.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') {
        autoRotate = !autoRotate;
      }
      if (e.key === 'q' || e.key === 'Q') {
        // toggle green/yellow
        const isDefault = floorUniforms.color1.value.equals(new THREE.Color(0x111111));
        floorUniforms.color1.value.set(isDefault ? 0x228B22 : 0x111111); // green
        floorUniforms.color2.value.set(isDefault ? 0xFFD700 : 0xaaaaaa); // yellow
      }
      if (e.key === 'w' || e.key === 'W') {
        // toggle black/white
        const isDefault = floorUniforms.color1.value.equals(new THREE.Color(0x111111));
        floorUniforms.color1.value.set(isDefault ? 0xaaaaaa : 0x111111);
        floorUniforms.color2.value.set(isDefault ? 0x111111 : 0xaaaaaa);
      }
      if (e.key === 't' || e.key === 'T') {
       // Painting shader always animated
if (paintingCanvas.material.uniforms) {
  paintingCanvas.material.uniforms.time.value = performance.now() * 0.001;
}
      }
    });
  </script>
</body>

</html>